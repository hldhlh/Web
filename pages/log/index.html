<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥å¿—</title>
    <link rel="stylesheet" href="styles.css">
    <!-- CDNåŠ è½½ä¼˜åŒ–è„šæœ¬ -->
    <script>
        // CDNé…ç½® - å¤šæºå¤‡é€‰ï¼Œç¡®ä¿å…¨çƒå¯è®¿é—®
        const CDN_CONFIG = {
            supabase: [
                'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2',
                'https://unpkg.com/@supabase/supabase-js@2',
                'https://cdnjs.cloudflare.com/ajax/libs/supabase-js/2.45.4/supabase.min.js',
                'https://fastly.jsdelivr.net/npm/@supabase/supabase-js@2',
                'https://cdn.skypack.dev/@supabase/supabase-js@2'
            ]
        };

        // CDNåŠ è½½å™¨
        class CDNLoader {
            constructor() {
                this.loadedScripts = new Set();
                this.loadedStyles = new Set();
                this.timeout = 8000; // 8ç§’è¶…æ—¶
            }

            // æ£€æµ‹èµ„æºç±»å‹
            getResourceType(url) {
                return 'js';
            }

            // æ£€æµ‹åœ°ç†ä½ç½®ä¼˜åŒ–CDNé¡ºåº
            async optimizeCDNOrder(urls) {
                const optimized = [...urls];
                
                try {
                    // ç®€å•çš„åœ°ç†æ£€æµ‹ - åŸºäºæ—¶åŒº
                    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    
                    if (timezone.includes('Asia') || timezone.includes('Shanghai') || timezone.includes('Hong_Kong')) {
                        // äºšæ´²åœ°åŒºä¼˜å…ˆä½¿ç”¨æ›´å¿«çš„CDN
                        optimized.sort((a, b) => {
                            if (a.includes('fastly')) return -1;
                            if (b.includes('fastly')) return 1;
                            return 0;
                        });
                    } else if (timezone.includes('Europe')) {
                        // æ¬§æ´²åœ°åŒºä¼˜åŒ–
                        optimized.sort((a, b) => {
                            if (a.includes('cdnjs') || a.includes('jsdelivr')) return -1;
                            if (b.includes('cdnjs') || b.includes('jsdelivr')) return 1;
                            return 0;
                        });
                    }
                } catch (error) {
                    console.log('åœ°ç†ä½ç½®æ£€æµ‹å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é¡ºåº');
                }
                
                return optimized;
            }

            // åŠ è½½å•ä¸ªèµ„æº
            loadResource(url, type) {
                return new Promise((resolve, reject) => {
                    let element;
                    
                    if (type === 'css') {
                        element = document.createElement('link');
                        element.rel = 'stylesheet';
                        element.href = url;
                    } else {
                        element = document.createElement('script');
                        element.src = url;
                    }

                    // è®¾ç½®è¶…æ—¶
                    const timeoutId = setTimeout(() => {
                        element.remove();
                        reject(new Error(`åŠ è½½è¶…æ—¶: ${url}`));
                    }, this.timeout);

                    element.onload = () => {
                        clearTimeout(timeoutId);
                        console.log(`âœ… CDNåŠ è½½æˆåŠŸ: ${url}`);
                        resolve(url);
                    };

                    element.onerror = () => {
                        clearTimeout(timeoutId);
                        element.remove();
                        reject(new Error(`åŠ è½½å¤±è´¥: ${url}`));
                    };

                    document.head.appendChild(element);
                });
            }

            // å°è¯•åŠ è½½å¤šä¸ªCDNæºç›´åˆ°æˆåŠŸ
            async loadWithFallback(name, urls) {
                const type = this.getResourceType(urls[0]);
                const optimizedUrls = await this.optimizeCDNOrder(urls);
                
                console.log(`ğŸš€ å¼€å§‹åŠ è½½ ${name}ï¼Œå°è¯•é¡ºåº:`, optimizedUrls);

                for (let i = 0; i < optimizedUrls.length; i++) {
                    const url = optimizedUrls[i];
                    try {
                        await this.loadResource(url, type);
                        
                        // ç‰¹æ®Šå¤„ç†ï¼šéªŒè¯Supabaseæ˜¯å¦çœŸæ­£å¯ç”¨
                        if (name === 'supabase') {
                            await this.waitForSupabase();
                        }
                        
                        console.log(`âœ… ${name} åŠ è½½æˆåŠŸ: ${url}`);
                        return url;
                    } catch (error) {
                        console.warn(`âŒ ${name} CDNå¤±è´¥ (${i + 1}/${optimizedUrls.length}): ${error.message}`);
                        
                        if (i === optimizedUrls.length - 1) {
                            throw new Error(`æ‰€æœ‰ ${name} CDNæºå‡ä¸å¯ç”¨`);
                        }
                        
                        // çŸ­æš‚å»¶è¿Ÿåå°è¯•ä¸‹ä¸€ä¸ªCDN
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
            }

            // ç­‰å¾…SupabaseåŠ è½½å®Œæˆ
            waitForSupabase() {
                return new Promise((resolve, reject) => {
                    let attempts = 0;
                    const maxAttempts = 50;
                    
                    const checkSupabase = () => {
                        attempts++;
                        
                        if (window.supabase && typeof window.supabase.createClient === 'function') {
                            resolve();
                        } else if (attempts >= maxAttempts) {
                            reject(new Error('SupabaseéªŒè¯è¶…æ—¶'));
                        } else {
                            setTimeout(checkSupabase, 100);
                        }
                    };
                    
                    checkSupabase();
                });
            }

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            showLoadingStatus(message, type = 'info') {
                const existingStatus = document.querySelector('.status-indicator');
                if (existingStatus) {
                    existingStatus.remove();
                }

                const status = document.createElement('div');
                status.className = `status-indicator ${type}`;
                status.textContent = message;
                document.body.appendChild(status);

                setTimeout(() => {
                    if (status && status.parentNode) {
                        status.remove();
                    }
                }, type === 'error' ? 8000 : 3000);
            }
        }

        // åˆå§‹åŒ–CDNåŠ è½½å™¨
        const cdnLoader = new CDNLoader();

        // é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹åŠ è½½CDN
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                cdnLoader.showLoadingStatus('æ­£åœ¨åŠ è½½æ•°æ®åº“è¿æ¥...', 'info');
                
                // åªåŠ è½½Supabase CDN
                const supabaseUrl = await cdnLoader.loadWithFallback('supabase', CDN_CONFIG.supabase);

                cdnLoader.showLoadingStatus('CDNåŠ è½½å®Œæˆ', 'success');
                console.log('ğŸ‰ Supabase CDNåŠ è½½å®Œæˆ:', supabaseUrl);
                
                // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶ï¼Œé€šçŸ¥ä¸»åº”ç”¨CDNå·²å‡†å¤‡å°±ç»ª
                window.dispatchEvent(new CustomEvent('cdnReady', {
                    detail: { supabase: supabaseUrl }
                }));
                
            } catch (error) {
                console.error('âŒ CDNåŠ è½½å¤±è´¥:', error);
                cdnLoader.showLoadingStatus('CDNåŠ è½½å¤±è´¥ï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨', 'error');
                
                // å³ä½¿CDNå¤±è´¥ä¹Ÿè¦åˆå§‹åŒ–åŸºæœ¬åŠŸèƒ½
                window.dispatchEvent(new CustomEvent('cdnError', {
                    detail: { error: error.message }
                }));
            }
        });
    </script>

</head>
<body>
    <div class="container">
        <h1 class="page-title">æ—¥å¿—</h1>

        <form id="logForm" class="form-container">
            <textarea id="logContent" name="content" rows="3"
                      class="form-textarea"
                      placeholder="è®°å½•..." required></textarea>
            <div class="form-actions">
                <button type="button" id="cancelBtn" class="btn btn-cancel hidden">
                    å–æ¶ˆ
                </button>
                <button type="submit" id="submitBtn" class="btn btn-primary">
                    ä¿å­˜
                </button>
            </div>
        </form>

        <div id="timeline" class="timeline-container">
            <!-- æ—¥å¿—æ¡ç›® -->
        </div>

        <div id="emptyState" class="empty-state hidden">
            æš‚æ— æ—¥å¿—
        </div>
    </div>

    <div id="deleteModal" class="modal hidden">
        <div class="modal-content">
            <p class="modal-text">ç¡®å®šåˆ é™¤ï¼Ÿ</p>
            <div class="modal-actions">
                <button id="cancelDelete" class="btn btn-cancel">
                    å–æ¶ˆ
                </button>
                <button id="confirmDelete" class="btn btn-danger">
                    åˆ é™¤
                </button>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html>
